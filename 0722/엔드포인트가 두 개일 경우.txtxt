서한빈 - UCC 담당자

-------------------
엔드포인트가 두 개일 경우

1. MongoDB 조회 : comment에는 story_id, plot_id 가 포함된 json 파일 response
2. Comment정보 조회 : endpoint 한 번: story_id를 request로 보내면 response로 plot_index와 penname, profile_img, content를 받아옴
앤드포인트가 하나일 경우
백엔드에서 몽고디비 조회 후, 리턴 받은 값을 파싱해서 Maria DB에서 comment 정보 json에 삽입하여 response

-------------------

네, 이해했습니다. 두 가지 시나리오를 비교해 보겠습니다.

1. 엔드포인트가 두 개인 경우:
   이 방식은 클라이언트 측에서 두 번의 API 호출이 필요합니다.

   장점:
   - 각 데이터베이스의 부하가 분산됩니다.
   - 필요에 따라 데이터를 선택적으로 가져올 수 있습니다.

   단점:
   - 클라이언트에서 두 번의 네트워크 요청이 필요하여 지연 시간이 증가할 수 있습니다.
   - 클라이언트 측에서 데이터를 조합해야 하므로 로직이 복잡해질 수 있습니다.

2. 엔드포인트가 하나인 경우:
   이 방식은 서버 측에서 데이터를 조합하여 하나의 응답으로 전송합니다.

   장점:
   - 클라이언트는 단일 요청으로 모든 필요한 데이터를 받을 수 있습니다.
   - 클라이언트 측 로직이 간단해집니다.
   - 네트워크 요청 횟수가 줄어들어 전체적인 응답 시간이 감소할 수 있습니다.

   단점:
   - 서버 측에서 추가적인 처리가 필요하므로 서버 부하가 증가할 수 있습니다.
   - 항상 모든 데이터를 조회하므로, 불필요한 데이터 전송이 발생할 수 있습니다.

추천:
상황에 따라 다르지만, 일반적으로는 엔드포인트가 하나인 경우가 더 효율적일 수 있습니다. 이유는 다음과 같습니다:

1. 성능: 클라이언트-서버 간 통신 횟수가 줄어들어 전체적인 응답 시간이 개선될 수 있습니다.
2. 간편성: 클라이언트 측 코드가 간단해지고, 데이터 관리가 용이해집니다.
3. 일관성: 서버에서 데이터를 조합하므로 데이터 일관성을 보장하기 쉽습니다.

그러나 다음과 같은 경우에는 두 개의 엔드포인트를 사용하는 것이 좋을 수 있습니다:

1. 데이터의 일부만 자주 필요한 경우
2. 두 데이터베이스의 부하를 분산시켜야 하는 경우
3. 마이크로서비스 아키텍처를 사용하는 경우

최종적인 선택은 시스템의 요구사항, 성능 목표, 그리고 개발 팀의 선호도에 따라 달라질 수 있습니다. 
필요하다면 두 방식의 성능을 실제로 테스트해보고 결정하는 것도 좋은 방법입니다.

-------------------

네, 엔드포인트가 하나인 경우도 충분히 구현 가능합니다. 실제 구현 방법을 간단히 설명해드리겠습니다.



```python
# 필요한 라이브러리 임포트
from flask import Flask, request, jsonify
from pymongo import MongoClient
import mysql.connector

app = Flask(__name__)

# MongoDB 연결
mongo_client = MongoClient('mongodb://localhost:27017/')
mongo_db = mongo_client['your_mongodb_database']
comment_collection = mongo_db['comments']

# MariaDB 연결
mariadb_connection = mysql.connector.connect(
    host="localhost",
    user="your_username",
    password="your_password",
    database="your_mariadb_database"
)
mariadb_cursor = mariadb_connection.cursor(dictionary=True)

@app.route('/get_comment_info', methods=['GET'])
def get_comment_info():
    story_id = request.args.get('story_id')
    
    if not story_id:
        return jsonify({"error": "story_id is required"}), 400
    
    # MongoDB에서 comment 정보 조회
    mongo_result = comment_collection.find_one({"story_id": story_id})
    
    if not mongo_result:
        return jsonify({"error": "Comment not found"}), 404
    
    plot_id = mongo_result.get('plot_id')
    
    # MariaDB에서 추가 정보 조회
    mariadb_query = """
    SELECT plot_index, penname, profile_img, content
    FROM comments
    WHERE story_id = %s
    """
    mariadb_cursor.execute(mariadb_query, (story_id,))
    maria_result = mariadb_cursor.fetchone()
    
    if not maria_result:
        return jsonify({"error": "Additional comment info not found"}), 404
    
    # 결과 조합
    result = {
        "story_id": story_id,
        "plot_id": plot_id,
        "plot_index": maria_result['plot_index'],
        "penname": maria_result['penname'],
        "profile_img": maria_result['profile_img'],
        "content": maria_result['content']
    }
    
    return jsonify(result)

if __name__ == '__main__':
    app.run(debug=True)```

-------------------

이 예제 코드는 Flask를 사용하여 단일 엔드포인트를 구현하는 방법을 보여줍니다. 주요 포인트는 다음과 같습니다:

MongoDB와 MariaDB에 모두 연결합니다.
단일 엔드포인트 /get_comment_info를 생성합니다.
클라이언트로부터 story_id를 받아 MongoDB에서 먼저 조회합니다.
MongoDB 조회 결과를 바탕으로 MariaDB에서 추가 정보를 조회합니다.
두 데이터베이스의 결과를 조합하여 하나의 JSON 응답으로 반환합니다.
이 방식의 장점은 다음과 같습니다:

클라이언트는 단일 요청으로 모든 필요한 정보를 얻을 수 있습니다.
서버에서 데이터 조합을 처리하므로 클라이언트 로직이 단순해집니다.
네트워크 요청 횟수가 줄어 전체적인 응답 시간이 개선될 수 있습니다.
주의할 점:

실제 구현 시 에러 처리, 연결 풀링, 보안 등을 더 자세히 고려해야 합니다.
데이터베이스 연결 정보는 환경 변수나 설정 파일로 관리하는 것이 좋습니다.
대량의 요청이 예상된다면 캐싱 전략을 고려해볼 수 있습니다.
이 접근 방식은 확실히 구현 가능하며, 많은 실제 시스템에서 사용되는 방식입니다. 구체적인 요구사항이나 성능 고려사항이 있다면 그에 맞게 코드를 조정할 수 있습니다.
